"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaginationLimit = exports.PaginationType = exports.Paginated = exports.FilterSuffix = exports.FilterOperator = void 0;
exports.paginate = paginate;
const common_1 = require("@nestjs/common");
const lodash_1 = require("lodash");
const querystring_1 = require("querystring");
const typeorm_1 = require("typeorm");
const OrmUtils_1 = require("typeorm/util/OrmUtils");
const filter_1 = require("./filter");
Object.defineProperty(exports, "FilterOperator", { enumerable: true, get: function () { return filter_1.FilterOperator; } });
Object.defineProperty(exports, "FilterSuffix", { enumerable: true, get: function () { return filter_1.FilterSuffix; } });
const helper_1 = require("./helper");
const logger = new common_1.Logger('nestjs-paginate');
class Paginated {
}
exports.Paginated = Paginated;
var PaginationType;
(function (PaginationType) {
    PaginationType["LIMIT_AND_OFFSET"] = "limit";
    PaginationType["TAKE_AND_SKIP"] = "take";
})(PaginationType || (exports.PaginationType = PaginationType = {}));
var PaginationLimit;
(function (PaginationLimit) {
    PaginationLimit[PaginationLimit["NO_PAGINATION"] = -1] = "NO_PAGINATION";
    PaginationLimit[PaginationLimit["COUNTER_ONLY"] = 0] = "COUNTER_ONLY";
    PaginationLimit[PaginationLimit["DEFAULT_LIMIT"] = 20] = "DEFAULT_LIMIT";
    PaginationLimit[PaginationLimit["DEFAULT_MAX_LIMIT"] = 100] = "DEFAULT_MAX_LIMIT";
})(PaginationLimit || (exports.PaginationLimit = PaginationLimit = {}));
function generateWhereStatement(queryBuilder, obj) {
    const toTransform = Array.isArray(obj) ? obj : [obj];
    return toTransform.map((item) => flattenWhereAndTransform(queryBuilder, item).join(' AND ')).join(' OR ');
}
function flattenWhereAndTransform(queryBuilder, obj, separator = '.', parentKey = '') {
    return Object.entries(obj).flatMap(([key, value]) => {
        if (obj.hasOwnProperty(key)) {
            const joinedKey = parentKey ? `${parentKey}${separator}${key}` : key;
            if (typeof value === 'object' && value !== null && !(0, helper_1.isFindOperator)(value)) {
                return flattenWhereAndTransform(queryBuilder, value, separator, joinedKey);
            }
            else {
                const property = (0, helper_1.getPropertiesByColumnName)(joinedKey);
                const { isVirtualProperty, query: virtualQuery } = (0, helper_1.extractVirtualProperty)(queryBuilder, property);
                const isRelation = (0, helper_1.checkIsRelation)(queryBuilder, property.propertyPath);
                const isEmbedded = (0, helper_1.checkIsEmbedded)(queryBuilder, property.propertyPath);
                const alias = (0, helper_1.fixColumnAlias)(property, queryBuilder.alias, isRelation, isVirtualProperty, isEmbedded, virtualQuery);
                const whereClause = queryBuilder['createWhereConditionExpression'](queryBuilder['getWherePredicateCondition'](alias, value));
                const allJoinedTables = queryBuilder.expressionMap.joinAttributes.reduce((acc, attr) => {
                    acc[attr.alias.name] = true;
                    return acc;
                }, {});
                const allTablesInPath = property.column.split('.').slice(0, -1);
                const tablesToJoin = allTablesInPath.map((table, idx) => {
                    if (idx === 0) {
                        return table;
                    }
                    return [...allTablesInPath.slice(0, idx), table].join('.');
                });
                tablesToJoin.forEach((table) => {
                    const pathSplit = table.split('.');
                    const fullPath = pathSplit.length === 1
                        ? ''
                        : `_${pathSplit
                            .slice(0, -1)
                            .map((p) => p + '_rel')
                            .join('_')}`;
                    const tableName = pathSplit[pathSplit.length - 1];
                    const tableAliasWithProperty = `${queryBuilder.alias}${fullPath}.${tableName}`;
                    const joinTableAlias = `${queryBuilder.alias}${fullPath}_${tableName}_rel`;
                    const baseTableAlias = allJoinedTables[joinTableAlias];
                    if (baseTableAlias) {
                        return;
                    }
                    else {
                        queryBuilder.leftJoin(tableAliasWithProperty, joinTableAlias);
                    }
                });
                return whereClause;
            }
        }
    });
}
async function paginate(query, repo, config) {
    var _a, _b, _c;
    const page = (0, helper_1.positiveNumberOrDefault)(query.page, 1, 1);
    const defaultLimit = config.defaultLimit || PaginationLimit.DEFAULT_LIMIT;
    const maxLimit = config.maxLimit || PaginationLimit.DEFAULT_MAX_LIMIT;
    const isPaginated = !(query.limit === PaginationLimit.COUNTER_ONLY ||
        (query.limit === PaginationLimit.NO_PAGINATION && maxLimit === PaginationLimit.NO_PAGINATION));
    const limit = query.limit === PaginationLimit.COUNTER_ONLY
        ? PaginationLimit.COUNTER_ONLY
        : isPaginated === true
            ? maxLimit === PaginationLimit.NO_PAGINATION
                ? (_a = query.limit) !== null && _a !== void 0 ? _a : defaultLimit
                : query.limit === PaginationLimit.NO_PAGINATION
                    ? defaultLimit
                    : Math.min((_b = query.limit) !== null && _b !== void 0 ? _b : defaultLimit, maxLimit)
            : defaultLimit;
    const sortBy = [];
    const searchBy = [];
    let [items, totalItems] = [[], 0];
    const queryBuilder = (0, helper_1.isRepository)(repo) ? repo.createQueryBuilder('__root') : repo;
    if ((0, helper_1.isRepository)(repo) && !config.relations && config.loadEagerRelations === true) {
        if (!config.relations) {
            typeorm_1.FindOptionsUtils.joinEagerRelations(queryBuilder, queryBuilder.alias, repo.metadata);
        }
    }
    if (isPaginated) {
        // Allow user to choose between limit/offset and take/skip.
        // However, using limit/offset can cause problems when joining one-to-many etc.
        if (config.paginationType === PaginationType.LIMIT_AND_OFFSET) {
            queryBuilder.limit(limit).offset((page - 1) * limit);
        }
        else {
            queryBuilder.take(limit).skip((page - 1) * limit);
        }
    }
    if (config.withDeleted) {
        queryBuilder.withDeleted();
    }
    if (config.relations) {
        const relations = Array.isArray(config.relations)
            ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(config.relations)
            : config.relations;
        const createQueryBuilderRelations = (prefix, relations, alias) => {
            Object.keys(relations).forEach((relationName) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const relationSchema = relations[relationName];
                queryBuilder.leftJoinAndSelect(`${alias !== null && alias !== void 0 ? alias : prefix}.${relationName}`, `${alias !== null && alias !== void 0 ? alias : prefix}_${relationName}_rel`);
                if (typeof relationSchema === 'object') {
                    createQueryBuilderRelations(relationName, relationSchema, `${alias !== null && alias !== void 0 ? alias : prefix}_${relationName}_rel`);
                }
            });
        };
        createQueryBuilderRelations(queryBuilder.alias, relations);
    }
    const dbType = ((0, helper_1.isRepository)(repo) ? repo.manager : repo).connection.options.type;
    const isMariaDbOrMySql = (dbType) => dbType === 'mariadb' || dbType === 'mysql';
    const isMMDb = isMariaDbOrMySql(dbType);
    let nullSort;
    if (config.nullSort) {
        if (isMMDb) {
            nullSort = config.nullSort === 'last' ? 'IS NULL' : 'IS NOT NULL';
        }
        else {
            nullSort = config.nullSort === 'last' ? 'NULLS LAST' : 'NULLS FIRST';
        }
    }
    if (config.sortableColumns.length < 1) {
        const message = "Missing required 'sortableColumns' config.";
        logger.debug(message);
        throw new common_1.ServiceUnavailableException(message);
    }
    if (query.sortBy) {
        for (const order of query.sortBy) {
            if ((0, helper_1.isEntityKey)(config.sortableColumns, order[0]) && ['ASC', 'DESC'].includes(order[1])) {
                sortBy.push(order);
            }
        }
    }
    if (!sortBy.length) {
        sortBy.push(...(config.defaultSortBy || [[config.sortableColumns[0], 'ASC']]));
    }
    for (const order of sortBy) {
        const columnProperties = (0, helper_1.getPropertiesByColumnName)(order[0]);
        const { isVirtualProperty } = (0, helper_1.extractVirtualProperty)(queryBuilder, columnProperties);
        const isRelation = (0, helper_1.checkIsRelation)(queryBuilder, columnProperties.propertyPath);
        const isEmbeded = (0, helper_1.checkIsEmbedded)(queryBuilder, columnProperties.propertyPath);
        let alias = (0, helper_1.fixColumnAlias)(columnProperties, queryBuilder.alias, isRelation, isVirtualProperty, isEmbeded);
        if (isMMDb) {
            if (isVirtualProperty) {
                alias = `\`${alias}\``;
            }
            if (nullSort) {
                queryBuilder.addOrderBy(`${alias} ${nullSort}`);
            }
            queryBuilder.addOrderBy(alias, order[1]);
        }
        else {
            if (isVirtualProperty) {
                alias = `"${alias}"`;
            }
            queryBuilder.addOrderBy(alias, order[1], nullSort);
        }
    }
    // When we partial select the columns (main or relation) we must add the primary key column otherwise
    // typeorm will not be able to map the result.
    let selectParams = config.select && query.select && !config.ignoreSelectInQueryParam
        ? config.select.filter((column) => query.select.includes(column))
        : config.select;
    if (!(0, helper_1.includesAllPrimaryKeyColumns)(queryBuilder, query.select)) {
        selectParams = config.select;
    }
    if ((selectParams === null || selectParams === void 0 ? void 0 : selectParams.length) > 0 && (0, helper_1.includesAllPrimaryKeyColumns)(queryBuilder, selectParams)) {
        const cols = selectParams.reduce((cols, currentCol) => {
            const columnProperties = (0, helper_1.getPropertiesByColumnName)(currentCol);
            const isRelation = (0, helper_1.checkIsRelation)(queryBuilder, columnProperties.propertyPath);
            cols.push((0, helper_1.fixColumnAlias)(columnProperties, queryBuilder.alias, isRelation));
            return cols;
        }, []);
        queryBuilder.select(cols);
    }
    if (config.where && (0, helper_1.isRepository)(repo)) {
        const baseWhereStr = generateWhereStatement(queryBuilder, config.where);
        queryBuilder.andWhere(`(${baseWhereStr})`);
    }
    if (config.searchableColumns) {
        if (query.searchBy && !config.ignoreSearchByInQueryParam) {
            for (const column of query.searchBy) {
                if ((0, helper_1.isEntityKey)(config.searchableColumns, column)) {
                    searchBy.push(column);
                }
            }
        }
        else {
            searchBy.push(...config.searchableColumns);
        }
    }
    if (query.search && searchBy.length) {
        queryBuilder.andWhere(new typeorm_1.Brackets((qb) => {
            var _a;
            // Explicitly handle the default case - multiWordSearch defaults to false
            const useMultiWordSearch = (_a = config.multiWordSearch) !== null && _a !== void 0 ? _a : false;
            if (!useMultiWordSearch) {
                // Strict search mode (default behavior)
                for (const column of searchBy) {
                    const property = (0, helper_1.getPropertiesByColumnName)(column);
                    const { isVirtualProperty, query: virtualQuery } = (0, helper_1.extractVirtualProperty)(qb, property);
                    const isRelation = (0, helper_1.checkIsRelation)(qb, property.propertyPath);
                    const isEmbedded = (0, helper_1.checkIsEmbedded)(qb, property.propertyPath);
                    const alias = (0, helper_1.fixColumnAlias)(property, qb.alias, isRelation, isVirtualProperty, isEmbedded, virtualQuery);
                    const condition = {
                        operator: 'ilike',
                        parameters: [alias, `:${property.column}`],
                    };
                    if (['postgres', 'cockroachdb'].includes(queryBuilder.connection.options.type)) {
                        condition.parameters[0] = `CAST(${condition.parameters[0]} AS text)`;
                    }
                    qb.orWhere(qb['createWhereConditionExpression'](condition), {
                        [property.column]: `%${query.search}%`,
                    });
                }
            }
            else {
                // Multi-word search mode
                const searchWords = query.search.split(' ').filter((word) => word.length > 0);
                searchWords.forEach((searchWord, index) => {
                    qb.andWhere(new typeorm_1.Brackets((subQb) => {
                        for (const column of searchBy) {
                            const property = (0, helper_1.getPropertiesByColumnName)(column);
                            const { isVirtualProperty, query: virtualQuery } = (0, helper_1.extractVirtualProperty)(subQb, property);
                            const isRelation = (0, helper_1.checkIsRelation)(subQb, property.propertyPath);
                            const isEmbedded = (0, helper_1.checkIsEmbedded)(subQb, property.propertyPath);
                            const alias = (0, helper_1.fixColumnAlias)(property, subQb.alias, isRelation, isVirtualProperty, isEmbedded, virtualQuery);
                            const condition = {
                                operator: 'ilike',
                                parameters: [alias, `:${property.column}_${index}`],
                            };
                            if (['postgres', 'cockroachdb'].includes(queryBuilder.connection.options.type)) {
                                condition.parameters[0] = `CAST(${condition.parameters[0]} AS text)`;
                            }
                            subQb.orWhere(subQb['createWhereConditionExpression'](condition), {
                                [`${property.column}_${index}`]: `%${searchWord}%`,
                            });
                        }
                    }));
                });
            }
        }));
    }
    if (query.filter) {
        (0, filter_1.addFilter)(queryBuilder, query, config.filterableColumns);
    }
    if (query.limit === PaginationLimit.COUNTER_ONLY) {
        totalItems = await queryBuilder.getCount();
    }
    else if (isPaginated) {
        ;
        [items, totalItems] = await queryBuilder.getManyAndCount();
    }
    else {
        items = await queryBuilder.getMany();
    }
    const sortByQuery = sortBy.map((order) => `&sortBy=${order.join(':')}`).join('');
    const searchQuery = query.search ? `&search=${query.search}` : '';
    const searchByQuery = query.searchBy && searchBy.length && !config.ignoreSearchByInQueryParam
        ? searchBy.map((column) => `&searchBy=${column}`).join('')
        : '';
    // Only expose select in meta data if query select differs from config select
    const isQuerySelected = (selectParams === null || selectParams === void 0 ? void 0 : selectParams.length) !== ((_c = config.select) === null || _c === void 0 ? void 0 : _c.length);
    const selectQuery = isQuerySelected ? `&select=${selectParams.join(',')}` : '';
    const filterQuery = query.filter
        ? '&' +
            (0, querystring_1.stringify)((0, lodash_1.mapKeys)(query.filter, (_param, name) => 'filter.' + name), '&', '=', { encodeURIComponent: (str) => str })
        : '';
    const options = `&limit=${limit}${sortByQuery}${searchQuery}${searchByQuery}${selectQuery}${filterQuery}`;
    let path = null;
    if (query.path !== null) {
        // `query.path` does not exist in RPC/WS requests and is set to null then.
        const { queryOrigin, queryPath } = (0, helper_1.getQueryUrlComponents)(query.path);
        if (config.relativePath) {
            path = queryPath;
        }
        else if (config.origin) {
            path = config.origin + queryPath;
        }
        else {
            path = queryOrigin + queryPath;
        }
    }
    const buildLink = (p) => path + '?page=' + p + options;
    const totalPages = isPaginated ? Math.ceil(totalItems / limit) : 1;
    const results = {
        data: items,
        meta: {
            itemsPerPage: limit === PaginationLimit.COUNTER_ONLY ? totalItems : isPaginated ? limit : items.length,
            totalItems: limit === PaginationLimit.COUNTER_ONLY || isPaginated ? totalItems : items.length,
            currentPage: page,
            totalPages,
            sortBy,
            search: query.search,
            searchBy: query.search ? searchBy : undefined,
            select: isQuerySelected ? selectParams : undefined,
            filter: query.filter,
        },
        // If there is no `path`, don't build links.
        links: path !== null
            ? {
                first: page == 1 ? undefined : buildLink(1),
                previous: page - 1 < 1 ? undefined : buildLink(page - 1),
                current: buildLink(page),
                next: page + 1 > totalPages ? undefined : buildLink(page + 1),
                last: page == totalPages || !totalItems ? undefined : buildLink(totalPages),
            }
            : {},
    };
    return Object.assign(new Paginated(), results);
}
//# sourceMappingURL=paginate.js.map